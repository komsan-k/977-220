üî¨ Lab 14: High-Level Synthesis (HLS) and AI Accelerator Integration in FPGA Systems
üß© 1. Objective

This laboratory explores High-Level Synthesis (HLS) workflows and AI hardware acceleration on FPGA platforms.
Students will learn to:

Develop computational accelerators using C/C++ or Python (PYNQ).

Integrate HLS-generated IP blocks into Verilog SoC systems.

Implement a Matrix Multiply / Neural Inference Engine on FPGA.

Compare RTL-based vs. HLS-based design performance.

‚öôÔ∏è 2. Equipment and Tools
Tool / Resource	Description
Xilinx Vitis HLS	High-Level Synthesis environment
Vivado / ModelSim	Integration and verification
FPGA board (Zybo / Nexys A7 / PYNQ-Z2)	Hardware platform
C/C++ Compiler / Python (PYNQ Jupyter)	Host control
AXI-Lite Interface	Communication with SoC CPU (MicroBlaze or ARM)
üß† 3. Background Theory
3.1 High-Level Synthesis (HLS)

HLS allows hardware designers to describe accelerators in C/C++ and automatically generate Verilog/VHDL RTL code.
This dramatically speeds up design time and enables complex algorithm implementation (e.g., DSP, ML inference).

Basic HLS flow:

Write algorithm in C/C++.

Add synthesis directives (#pragma HLS) to optimize pipelining and parallelism.

Generate Verilog IP.

Integrate IP into an FPGA SoC system using AXI interfaces.

3.2 AI Accelerator Concept

A Neural Network Processing Unit (NPU) performs matrix-vector multiplications, activations, and accumulation ‚Äî ideal for FPGA parallelization.

Simplified structure:

Inputs  ‚Üí  Multiply‚ÄìAccumulate Array  ‚Üí  Activation (ReLU/Sigmoid)  ‚Üí  Output

‚öôÔ∏è 4. HLS Module Design (Matrix Multiplication Example)
4.1 C Code for HLS Accelerator
#include "ap_int.h"

#define N 4

void matmul_accel(ap_int<8> A[N][N], ap_int<8> B[N][N], ap_int<16> C[N][N]) {
#pragma HLS PIPELINE
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            ap_int<16> sum = 0;
            for (int k = 0; k < N; k++) {
#pragma HLS UNROLL
                sum += A[i][k] * B[k][j];
            }
            C[i][j] = sum;
        }
    }
}

4.2 HLS Directives Explanation
Directive	Function
#pragma HLS PIPELINE	Enables concurrent loop execution.
#pragma HLS UNROLL	Expands inner loops for full parallel multiply‚Äìaccumulate.
#pragma HLS INTERFACE m_axi	Generates AXI interfaces for external data access.
4.3 Generated Verilog Wrapper (simplified)
module matmul_accel (
  input ap_clk,
  input ap_rst,
  input ap_start,
  output ap_done,
  input [7:0] A_0, B_0,
  output [15:0] C_0
);
// Generated by Vitis HLS ‚Äì computation mapped to DSP slices
endmodule

üß© 5. Verilog SoC Integration

Once HLS generates the matmul_accel IP, instantiate it within your existing SoC (from Lab 12/13).

module SoC_AI(
  input clk, rst,
  input [7:0] addr, din,
  input we, re,
  output [15:0] dout
);
  wire sel_hls;
  assign sel_hls = (addr[7:4] == 4'h4); // Address range 0x40‚Äì0x4F

  wire done;
  matmul_accel hls_core (
    .ap_clk(clk),
    .ap_rst(rst),
    .ap_start(we & sel_hls),
    .ap_done(done)
  );
endmodule

üßÆ 6. Host Control (Python on PYNQ Board)
from pynq import Overlay, allocate
import numpy as np

overlay = Overlay("soc_ai.bit")
matmul = overlay.matmul_accel_0

A = np.array([[1,2,3,4],[4,3,2,1],[1,0,1,0],[0,1,0,1]], dtype=np.int8)
B = np.array([[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]], dtype=np.int8)
C = np.zeros((4,4), dtype=np.int16)

matmul.call(A, B, C)
print("Matrix C Result:\n", C)

üìä 7. Observation Table
Input A (4x4)	Input B (4x4)	Output C (4x4)	Time (¬µs)	Speedup
Random	Random	Correct	3.5	12√ó faster than C loop
üí° 8. Discussion Points

How do HLS pipelines improve performance compared to pure Verilog RTL?

What are the limitations of HLS (latency, resource mapping)?

Why is AXI-Lite essential for IP-to-SoC integration?

Compare manual Verilog design vs. HLS auto-generated logic in resource utilization.

üß† 9. Post-Lab Exercises

Modify the HLS design to implement a 3x3 convolution kernel for CNNs.

Integrate sigmoid/tanh activation logic in hardware.

Add a DMA controller for high-speed data transfer.

Profile FPGA utilization for different unroll factors.

Compare performance vs. CPU-only computation.

üßæ 10. Outcome

Students will be able to:

Develop and synthesize hardware accelerators from high-level languages.

Integrate HLS-generated IP into Verilog-based SoC architectures.

Validate FPGA-accelerated AI computation.

Compare RTL vs. HLS design efficiency and trade-offs.

üìò 11. References

Xilinx, Vitis HLS User Guide (UG1399)

Xilinx, PYNQ Framework Documentation

Pong P. Chu, FPGA Prototyping by Verilog Examples

Palnitkar, Verilog HDL: A Guide to Digital Design and Synthesis

D. Harris & S. Harris, Digital Design and Computer Architecture (ARM Edition)
